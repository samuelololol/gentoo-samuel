diff -ruN pcmanx-gtk2-0.3.9/data/Makefile.am pcmanx-mls-gtk2-0.3.9/data/Makefile.am
--- pcmanx-gtk2-0.3.9/data/Makefile.am	2009-04-30 23:46:46.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/data/Makefile.am	2009-09-29 01:44:13.000000000 +0800
@@ -17,6 +17,8 @@
 
 pcmanx_DATA = \
 	sitelist \
+	_B2U \
+	_U2B \
 	emoticons
 
 pcmanxdir = $(datadir)/pcmanx
diff -ruN pcmanx-gtk2-0.3.9/data/Makefile.in pcmanx-mls-gtk2-0.3.9/data/Makefile.in
--- pcmanx-gtk2-0.3.9/data/Makefile.in	2009-08-03 16:38:21.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/data/Makefile.in	2009-09-29 01:45:45.000000000 +0800
@@ -249,6 +249,8 @@
 
 pcmanx_DATA = \
 	sitelist \
+	_B2U \
+	_U2B \
 	emoticons
 
 pcmanxdir = $(datadir)/pcmanx
diff -ruN pcmanx-gtk2-0.3.9/description-pak pcmanx-mls-gtk2-0.3.9/description-pak
--- pcmanx-gtk2-0.3.9/description-pak	1970-01-01 08:00:00.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/description-pak	2009-09-26 18:10:08.000000000 +0800
@@ -0,0 +1,8 @@
+專為 BBS 使用者設計的友善 telnet 連線程式
+PCMan X 是知名 BBS 多功能連線軟體 PCMan 系列的 GPL 版本，
+以成為功能齊全、操作簡單、能處理雙位元組字元、
+方便 BBS 瀏覽的 telnet 連線軟體為目標，
+提供一些方便的功能，例如分頁瀏覽、自動登入等等。
+.
+這個版本單純只使用 gtk2 和 xft
+開發，所以不會有複雜的相依性。
diff -ruN pcmanx-gtk2-0.3.9/src/core/termdata.cpp pcmanx-mls-gtk2-0.3.9/src/core/termdata.cpp
--- pcmanx-gtk2-0.3.9/src/core/termdata.cpp	2009-08-03 10:20:01.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/core/termdata.cpp	2009-09-26 18:05:46.000000000 +0800
@@ -27,6 +27,9 @@
 #include "termdata.h" // class's header file
 #include "termview.h" // class's header file
 #include "termsel.h" // class's header file
+
+#include "encodingdata.h"
+
 #include <string.h>
 #include <stdint.h>
 
@@ -80,35 +83,38 @@
 		m_Inverse = attr.m_Inverse;
 	if( flags & STA_INVISIBLE )
 		m_Invisible = attr.m_Invisible;
+	if( flags & STA_ENCODING )
+		m_Encoding = attr.m_Encoding;
 	m_NeedUpdate = 1;
 }
 
 // I don't know whether assign an 'short' to this 'object' directly will cause 
 // problems or not hence preventing using it.  Otherwise I can return 7 directly;
-short 
+int
 CTermCharAttr::GetDefVal(){
 	CTermCharAttr attr;
-	*(short*)&attr=0;
+	*(int*)&attr=0;
 	attr.m_Fg = 7;
-	return *(short*)&attr;
+	return *(int*)&attr;
 }
 
 
 void 
-CTermCharAttr::SetToDefault(){ *(short*)this = 0;	m_Fg=7;}
+CTermCharAttr::SetToDefault(){ *(int*)this = 0;	m_Fg=7;}
 // We cannot use == to compare two CTermCharAttr directly because of some special flags,
 //so us use this function to compare.
 bool 
-CTermCharAttr::IsSameAttr(short val2)
+CTermCharAttr::IsSameAttr(int val2)
 {
-		CTermCharAttr* pAttr = (CTermCharAttr*)&val2;
-		pAttr->m_CharSet = m_CharSet;
-		pAttr->m_NeedUpdate = m_NeedUpdate;
-		return val2 == this->AsShort();
+	CTermCharAttr* pAttr = (CTermCharAttr*)&val2;
+	pAttr->m_CharSet = m_CharSet;
+	pAttr->m_NeedUpdate = m_NeedUpdate;
+	pAttr->m_Encoding = m_Encoding;
+	return val2 == this->AsInt();
 }
 bool
 CTermCharAttr::operator==(CTermCharAttr& attr){
-	if(IsSameAttr(attr.AsShort()))
+	if(IsSameAttr(attr.AsInt()))
 		return true;
 	return false;
 }
@@ -138,6 +144,7 @@
 #ifdef USE_IPLOOKUP
 	regcomp( &m_RegIp, "([0-9]{1,3}\\.){3}([0-9]{1,3}|\\*)", REG_EXTENDED );
 #endif
+	regcomp( &m_RegEnc, "@[a-z]{0,4}-", REG_EXTENDED );
 	m_LineCounter = 0;
 }
 
@@ -159,6 +166,7 @@
 #ifdef USE_IPLOOKUP
 	regfree(&m_RegIp);
 #endif
+	regfree(&m_RegEnc);
 }
 
 
@@ -176,7 +184,7 @@
             unsigned short Cols = (ColsPerPage < m_ColsPerPage)?ColsPerPage:m_ColsPerPage;
             //Copy context of old into new one.
             memcpy(NewLine, m_Screen[i], Cols);
-            memcpy(GetLineAttr(NewLine, ColsPerPage), GetLineAttr(m_Screen[i]), sizeof(short)*Cols);
+            memcpy(GetLineAttr(NewLine, ColsPerPage), GetLineAttr(m_Screen[i]), sizeof(int)*Cols);
             delete []m_Screen[i];
             m_Screen[i] = NewLine;
         }
@@ -229,7 +237,7 @@
 		memset( NewLine, ' ', ColsPerPage);
 		NewLine[ColsPerPage] = '\0';
 		CTermCharAttr DefAttr;	DefAttr.SetToDefault();	DefAttr.SetNeedUpdate(true);
-		memset16( GetLineAttr(NewLine, ColsPerPage), DefAttr.AsShort(), ColsPerPage);
+		memset32( GetLineAttr(NewLine, ColsPerPage), DefAttr.AsInt(), ColsPerPage);
 }
 
 // LF handler
@@ -362,6 +370,53 @@
 					for( col = m_CaretPos.x+1; col < m_ColsPerPage && pAttr[col].IsHyperLink(); col++ )
 						pAttr[col].SetNeedUpdate(true);
 				}
+
+				// check encoding shift code
+				if (ch == '@')
+				{
+					m_EncCmdLine[0] = '@';
+					m_pEncCmdLine = &m_EncCmdLine[1];
+				}
+				else
+				{
+					if (m_EncCmdLine[0] == '@')
+					{
+						if (m_pEncCmdLine < (m_EncCmdLine + sizeof(m_EncCmdLine)))
+						{
+							if (ch >= 'a' && ch <= 'z')
+							{
+								*m_pEncCmdLine = ch;
+								m_pEncCmdLine++;
+							}
+							else if (ch == '#')
+							{
+								if (m_pEncCmdLine < (m_EncCmdLine + sizeof(m_EncCmdLine)))
+								{
+									*m_pEncCmdLine = '\0';
+									ParseEncoding( (const char*)m_EncCmdLine );
+									m_EncCmdLine[0] = '\0';
+									m_pEncCmdLine = m_EncCmdLine;
+								}
+								else
+								{
+									m_EncCmdLine[0] = '\0'; // Not shift code, reset
+									m_pEncCmdLine = m_EncCmdLine;
+								}
+							}
+							else
+							{
+								m_EncCmdLine[0] = '\0';  // Not shift code, reset
+								m_pEncCmdLine = m_EncCmdLine;
+							}
+						}
+						else
+						{
+							m_EncCmdLine[0] = '\0';  // Not shift code, reset
+							m_pEncCmdLine = m_EncCmdLine;
+						}
+					}
+				}
+
 				//	Advance the caret after character input.
 				m_CaretPos.x++;
 			break;
@@ -429,7 +484,7 @@
 	for( i = 1; i <= n; i++ )
 	{
 		memset( m_Screen[end+i], ' ', m_ColsPerPage-1 );
-		memset16( GetLineAttr(m_Screen[end+i]), m_CurAttr.AsShort(), m_ColsPerPage-1 );	
+		memset32( GetLineAttr(m_Screen[end+i]), m_CurAttr.AsInt(), m_ColsPerPage-1 );
 		SetWholeLineUpdate(m_Screen[end+i]);
 	}
 }
@@ -454,7 +509,7 @@
 	for( i = 1; i <= n; i++ )
 	{
 		memset( m_Screen[end-i], ' ', m_ColsPerPage-1 );
-		memset16( GetLineAttr(m_Screen[end-i]), m_CurAttr.AsShort(), m_ColsPerPage-1 );	
+		memset32( GetLineAttr(m_Screen[end-i]), m_CurAttr.AsInt(), m_ColsPerPage-1 );
 		SetWholeLineUpdate(m_Screen[end-i]);
 	}
 }
@@ -512,6 +567,8 @@
 					p1=1;
 				GoToXY( m_CaretPos.x - p1, m_CaretPos.y );
 				break;
+			case 'z':
+				break;
 			case 'r':	// Set Scroll Region
 				switch(n)
 				{
@@ -671,12 +728,12 @@
 	case 0:		// Clear from current position to end of line.
 		memset(&pLine[m_CaretPos.x],' ',m_ColsPerPage-m_CaretPos.x);
 		//memset16(&pAttr[m_CaretPos.x],CTermCharAttr::GetDefVal(),m_ColsPerPage-m_CaretPos.x);
-		memset16(&pAttr[m_CaretPos.x],*(short*)&m_CurAttr,m_ColsPerPage-m_CaretPos.x);
+		memset32(&pAttr[m_CaretPos.x],*(int*)&m_CurAttr,m_ColsPerPage-m_CaretPos.x);
 		SetLineUpdate(pLine, m_CaretPos.x, m_ColsPerPage );
 		break;
 	case 1:	// Clear from head of line to current position.
 		memset(pLine, ' ',m_CaretPos.x);
-		memset16(pAttr ,CTermCharAttr::GetDefVal(),m_CaretPos.x);
+		memset32(pAttr ,CTermCharAttr::GetDefVal(),m_CaretPos.x);
 		SetLineUpdate(pLine, 0, m_CaretPos.x+1);
 		break;
 	default:
@@ -699,10 +756,14 @@
 		}
 		if( param < 30 )	// property code
 		{
+			int tmp_enc = m_CurAttr.GetEncoding();
 			switch(param)
 			{
 			case 0:		// normal
+				// Reserve Encoding shift information
 				m_CurAttr.SetToDefault();
+				if (tmp_enc > 0)
+					m_CurAttr.SetEncoding(tmp_enc);
 				break;
 			case 1:		// bright foreground
 				m_CurAttr.SetBright(true);
@@ -735,6 +796,32 @@
 	}
 }
 
+void CTermData::ParseEncoding(const char *pParam)
+{
+	int i = 0;
+	char code_name[5];
+	code_name[0] = '\0';
+	const char* p = pParam + 1;
+
+	for ( ; i < 4 && p != '\0'; i++, p++)
+		code_name[i] = *p;
+	code_name[i] = '\0';
+
+	if (code_name[0] == '\0')
+		m_CurAttr.SetEncoding(0);
+	else
+	{
+		for (int k = 1; k < EncodingData::GetEntrySize(); k++)
+		{
+			if (strcmp(code_name, EncodingData::GetEncodingLang(k)) == 0)
+			{
+				m_CurAttr.SetEncoding(k);
+				break;
+			}
+		}
+	}
+}
+
 void CTermData::memset16(void *dest, short val, size_t n)
 {
 	uint16_t *dest16 = (uint16_t *) dest;
@@ -742,6 +829,13 @@
 		*dest16++ = val;
 }
 
+void CTermData::memset32(void *dest, int val, size_t n)
+{
+	int* dest32 = (int*)dest;
+	int* end = dest32 + n;
+	for ( ; dest32 < end; dest32++ )
+		*dest32 = val;
+}
 
 static gboolean update_view(CTermData* _this)
 {
@@ -759,6 +853,7 @@
 #ifdef USE_IPLOOKUP
 	DetectIpAddrs();
 #endif
+	DetectShiftedEncoding();
 
  	if( m_pView && m_pView->IsVisible() && !m_WaitUpdateDisplay )
 	{
@@ -994,6 +1089,55 @@
 
 #endif
 
+/* Detect encoding shift control code (called from UpdateDisplay()) */
+void CTermData::DetectShiftedEncoding()
+{
+	int iline = m_FirstLine;
+	int ilast_line = iline + m_RowsPerPage;
+	bool start_shift = false;
+	int shift_code = 0;
+
+	regmatch_t match;
+
+	for ( ; iline < ilast_line; iline++ )
+	{
+		char* line = m_Screen[iline];
+		CTermCharAttr* attr = GetLineAttr( line );
+		// [TODO] Clear all encoding shift
+		for (int col = 0; col < m_ColsPerPage; col++)
+			;
+
+		const char* p = line;
+
+		while (p < line + m_ColsPerPage && regexec( &m_RegEnc, p, 1, &match, 0) == 0)
+		{
+			int i, offset = p - line;
+			printf("offset %d\n", offset);
+			char code_name[5];
+			code_name[0] = '\0';
+			for (i = 0; i < 4 && i < (match.rm_eo - match.rm_so - 2); i++)
+				code_name[i] = p[match.rm_so + 1 + i];
+			code_name[i] = '\0';
+
+			for (int k = 0; k < match.rm_so; k++)
+				if (attr[offset + k].GetEncoding() != shift_code)
+					attr[offset + k].SetNeedUpdate(true);
+
+			if (code_name[0] == '\0')
+				shift_code = 0;
+			else
+				for (int k = 0 ; k < EncodingData::GetEntrySize(); k++)
+					if ( strcmp(code_name, EncodingData::GetEncodingLang(k)) == 0)
+					{
+						shift_code = k;
+						break;
+					}
+
+			p += match.rm_eo + 1;
+		}
+	}
+}
+
 typedef struct {
 	CTermData* pTermData;
 	string*    text;
@@ -1075,7 +1219,7 @@
 		string line;
 		for ( int i = col1; i < col2; i++ )
 		{
-			if( !attr.IsSameAttr( pAttr[i].AsShort() ) )
+			if( !attr.IsSameAttr( pAttr[i].AsInt() ) )
 			{
 				// Here we've got a characters with different attributes.
 				line += GetChangedAttrStr( attr, pAttr[i] );
diff -ruN pcmanx-gtk2-0.3.9/src/core/termdata.h pcmanx-mls-gtk2-0.3.9/src/core/termdata.h
--- pcmanx-gtk2-0.3.9/src/core/termdata.h	2009-04-30 23:46:47.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/core/termdata.h	2009-09-26 16:39:54.000000000 +0800
@@ -42,6 +42,7 @@
 #define BIT_NUMBER_OF_BOOL 1
 #define BIT_NUMBER_OF_CHARSET 2
 #define BIT_NUMBER_OF_COLOR 3
+#define BIT_NUMBER_OF_ENCODING 16
 #define SIZE_OF_COLOR_TABLE 16
 
 // Flags used by CTermCharAttr::SetTextAttr() & CTermData::SetTextAttr().
@@ -52,6 +53,7 @@
 #define		STA_UNDERLINE	16
 #define		STA_INVERSE		32
 #define		STA_INVISIBLE	64
+#define		STA_ENCODING	128
 #define		STA_ALL			255
 
 
@@ -91,6 +93,7 @@
 #endif
 	inline bool IsNeedUpdate(){return (m_NeedUpdate==1?true:false);}
 	inline short GetCharSet(){return (short)m_CharSet;}
+	inline short GetEncoding() { return m_Encoding; }
 	//Public setter:Neversay 15/Jan/2005
 	inline static bool SetDefaultColorTable(int index, GdkColor* newColor){
 		if(index >= 0 && index < SIZE_OF_COLOR_TABLE){
@@ -128,12 +131,18 @@
 			return true;
 		}return false;
 	}
+	inline bool SetEncoding(short code){
+		if (code >= 0){
+			m_Encoding = code;
+			return true;
+		}return false;
+	}
 
 	//Transform the CTermCharAttr into short value.
-	inline short AsShort(){	return *(short*)this;	}
+	inline int AsInt(){	return *(int*)this;	}
 
 	//Get default setting of CTermCharAttr.
-	static short GetDefVal();
+	static int GetDefVal();
 	//Set this to default value.
 	void SetToDefault();
 
@@ -146,7 +155,7 @@
 		return &pColorTable[( m_Inverse ? m_Fg : m_Bg )];
 	}
 
-	bool IsSameAttr(short val2);
+	bool IsSameAttr(int val2);
 
 	// Overloaded operator ==
 	bool operator==(CTermCharAttr& attr);
@@ -172,6 +181,20 @@
 	unsigned char m_NeedUpdate:BIT_NUMBER_OF_BOOL;	// a flag indicate the need for re-drawing
 	unsigned char m_CharSet:BIT_NUMBER_OF_CHARSET;	// character set, = CS_ASCII, CS_MBCS1, or CS_MBCS2
 	//-------------- 1 byte ----------
+	unsigned short m_Encoding:BIT_NUMBER_OF_ENCODING;	// encoding
+};
+
+class CTermCharEncAttr
+{
+public:
+	bool IsEncodingShifted() { return m_Is_Encoding_Shift; }
+	int GetShiftedEncoding() { return m_Shifted_Encoding; }
+	bool SetShiftedEncoding(bool shift) { return m_Is_Encoding_Shift = shift; }
+	void SetToDefault() { m_Is_Encoding_Shift = false; m_Shifted_Encoding = 0; }
+
+protected:
+	bool m_Is_Encoding_Shift;
+	int m_Shifted_Encoding;
 };
 
 /*
@@ -232,10 +255,13 @@
 #ifdef USE_IPLOOKUP
 	void DetectIpAddrs();
 #endif
+	void DetectShiftedEncoding();  // detect encoding shift
 	void UpdateDisplay();
 	void DoUpdateDisplay();
 	static void memset16( void* dest, short val, size_t n );
+	static void memset32( void* dest, int val, size_t n );
 	inline void ParseAnsiColor( const char* pParam );
+	inline void ParseEncoding( const char* pParam );
 	inline void EraseLine( int p );
 	void ClearScreen( int p );
 	inline void GoToXY( int x, int y );
@@ -288,7 +314,7 @@
 		// Neversay:The structure is show below:
 		// [ ColsPerPage*char + '\0' + ColsPerPage*CTermCharAttr ]
 		// so size is: ColsPerPage*1 + 1 + ColsPerPage*sizeof(CTermCharAttr)
-		char * NewLine = new char[ 1 + ColsPerPage * ( 1 + sizeof( short ) ) ];
+		char * NewLine = new char[ 1 + ColsPerPage * ( 1 + sizeof( int ) ) ];
 
 		InitNewLine( NewLine, ColsPerPage );
 		return NewLine;
@@ -322,6 +348,10 @@
 	unsigned char m_CmdLine[ 33 ];
 	unsigned char* m_pCmdLine;
 
+	// encoding shift code buffer, used to store encoding shift command
+	unsigned char m_EncCmdLine[ 33 ];
+	unsigned char* m_pEncCmdLine;
+
 	// Point to screen buffer of terminal
 	char** m_Screen;
 	// m_Screen = new (char*)[m_RowCount];
@@ -345,6 +375,7 @@
 #ifdef USE_IPLOOKUP
 	regex_t m_RegIp;
 #endif
+	regex_t m_RegEnc;
 };
 inline bool operator == (GdkPoint& pt1, GdkPoint& pt2)
 {	return (pt1.x == pt2.x && pt1.y == pt2.y);	}
diff -ruN pcmanx-gtk2-0.3.9/src/core/termview.cpp pcmanx-mls-gtk2-0.3.9/src/core/termview.cpp
--- pcmanx-gtk2-0.3.9/src/core/termview.cpp	2009-05-29 01:44:52.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/core/termview.cpp	2009-09-26 16:42:29.000000000 +0800
@@ -25,6 +25,9 @@
 #include "termdata.h"
 #include "termsel.h"
 
+#include "encodingdata.h"
+#include "Ucs2Conv.h"
+
 #include <string>
 
 #include <gdk/gdkx.h>
@@ -512,7 +515,19 @@
 			if( ' ' != *pLine && '\0' != *pLine )
 			{
 				gsize wl;
-				gchar *utf8_ch = g_convert( pLine, w, "UTF-8", m_pTermData->m_Encoding.c_str(), NULL, &wl, NULL);
+				gchar *utf8_ch = NULL;
+				short encoding = pAttr[i].GetEncoding();
+
+				if (encoding == 0)
+				{
+					if (m_pTermData->m_Encoding.compare("Big5") == 0)
+						utf8_ch = m_UcsConv->Big52Utf8(pLine, 1, &wl);
+					else
+						utf8_ch = g_convert( pLine, w, "UTF-8", m_pTermData->m_Encoding.c_str(), NULL, &wl, NULL);
+				}
+				else if (encoding > 0 && encoding < EncodingData::GetEntrySize())
+					utf8_ch = g_convert( pLine, w, "UTF-8", EncodingData::GetEncodingName(encoding), NULL, &wl, NULL);
+
 				if( utf8_ch )
 				{
 					XftFont* font;
@@ -547,7 +562,7 @@
 		}
 
 		// two cells have the same attributes
-		if( i == 0 && pAttr[0].IsSameAttr( pAttr[1].AsShort() ) && bSel[0] == bSel[1] )
+		if( i == 0 && pAttr[0].IsSameAttr( pAttr[1].AsInt() ) && bSel[0] == bSel[1] )
 			break;
 	}
 	gdk_gc_set_clip_rectangle( m_GC, NULL );
diff -ruN pcmanx-gtk2-0.3.9/src/core/termview.h pcmanx-mls-gtk2-0.3.9/src/core/termview.h
--- pcmanx-gtk2-0.3.9/src/core/termview.h	2009-04-30 23:46:47.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/core/termview.h	2009-09-26 16:44:01.000000000 +0800
@@ -28,6 +28,8 @@
 #include "view.h"
 #include "caret.h"
 
+#include "Ucs2Conv.h"
+
 #include <string>
 
 #include <X11/Xft/Xft.h>
@@ -80,6 +82,9 @@
     void SetVerticalCenterAlign( bool is_vcenter );
     void SetTermData(CTermData* data){	m_pTermData = data;	}
 
+    void SetUcs2Conv(CUcs2Conv *conv) { m_UcsConv = conv; }
+    CUcs2Conv* GetUcs2Conv() { return m_UcsConv; }
+
 protected:
     void OnPaint(GdkEventExpose* evt);
     void OnSetFocus(GdkEventFocus* evt);
@@ -140,6 +145,7 @@
     // Mouse Cursor State for Click Behaviour
     // Hand=-1, Normal=0, Exit=1, BullsEye=2, PageDown=3, PageUp=4, End=5, Home=6
     static int m_CursorState;
+    CUcs2Conv* m_UcsConv;
 };
 
 #endif
diff -ruN pcmanx-gtk2-0.3.9/src/encodingdata.cpp pcmanx-mls-gtk2-0.3.9/src/encodingdata.cpp
--- pcmanx-gtk2-0.3.9/src/encodingdata.cpp	1970-01-01 08:00:00.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/encodingdata.cpp	2009-09-26 16:46:05.000000000 +0800
@@ -0,0 +1,55 @@
+/*
+
+*/
+
+#include <glib/gi18n.h>
+
+#include "encodingdata.h"
+
+gchar* EncodingData::m_entries[] = {
+	"Default",
+	"EUC-KR",
+	"CP874",
+	"CP1258",
+	"CP1252"
+};
+
+gchar* EncodingData::m_entry_langs[] = {
+	"",
+	"ko",
+	"th",
+	"vi",
+	"wes"
+};
+
+gchar* EncodingData::m_entry_definitions[] = {
+	N_("Default"),
+	N_("Korean (EUC-KR)"),
+	N_("Thai (CP874)"),
+	N_("Vietnamese (CP1258)"),
+	N_("Western Europe (CP1252)")
+};
+
+gchar* EncodingData::GetEncodingName(int code)
+{
+	if (code < 0 || code >= MAX_ENCODING_ENTRIES)
+		return NULL;
+
+	return m_entries[code];
+}
+
+gchar* EncodingData::GetEncodingDescription(int code)
+{
+	if (code < 0 || code >= MAX_ENCODING_ENTRIES)
+		return NULL;
+
+	return m_entry_definitions[code];
+}
+
+gchar* EncodingData::GetEncodingLang(int code)
+{
+	if (code < 0 || code >= MAX_ENCODING_ENTRIES)
+		return NULL;
+
+	return m_entry_langs[code];
+}
\ 檔案末沒有 newline 字元
diff -ruN pcmanx-gtk2-0.3.9/src/encodingdata.h pcmanx-mls-gtk2-0.3.9/src/encodingdata.h
--- pcmanx-gtk2-0.3.9/src/encodingdata.h	1970-01-01 08:00:00.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/encodingdata.h	2009-09-26 16:47:16.000000000 +0800
@@ -0,0 +1,30 @@
+/*
+
+*/
+
+#ifndef _ENCODING_DATA_H_
+#define _ENCODING_DATA_H_
+
+#define MAX_ENCODING_ENTRIES 5
+
+#include <glib.h>
+#include "pcmanx_utils.h"
+
+class EncodingData
+{
+private:
+	static const gint m_size = MAX_ENCODING_ENTRIES;
+	static gchar* m_entries[];
+	static gchar* m_entry_definitions[];
+	static gchar* m_entry_langs[];
+
+public:
+	static const gchar EncodingCodeStartChar = '@';
+	static const gchar EncodingCodeEndChar = '#';
+	static gint GetEntrySize() { return m_size; }
+	X_EXPORT static gchar* GetEncodingName(int code);
+	static gchar* GetEncodingDescription(int code);
+	X_EXPORT static gchar* GetEncodingLang(int code);
+};
+
+#endif /* _ENCODING_DATA_H_ */
\ 檔案末沒有 newline 字元
diff -ruN pcmanx-gtk2-0.3.9/src/mainframe.cpp pcmanx-mls-gtk2-0.3.9/src/mainframe.cpp
--- pcmanx-gtk2-0.3.9/src/mainframe.cpp	2009-08-03 10:20:01.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/mainframe.cpp	2009-09-26 17:16:45.000000000 +0800
@@ -32,6 +32,8 @@
 #include "notebook.h"
 #include "telnetcon.h"
 
+#include "encodingdata.h"
+
 #include "inputdialog.h"
 #include "editfavdlg.h"
 #include "sitedlg.h"
@@ -41,6 +43,8 @@
 #include "emoticondlg.h"
 #include "downarticledlg.h"
 
+#include "Ucs2Conv.h"
+
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <unistd.h>
@@ -176,7 +180,7 @@
 	LoadIcons();
 
 
-	gtk_window_set_title (GTK_WINDOW (m_Widget), "PCMan X "VERSION );
+	gtk_window_set_title (GTK_WINDOW (m_Widget), "PCMan X (MLS) "VERSION );
 	
 	m_pNotebook = new CNotebook();
 	gtk_notebook_set_scrollable(GTK_NOTEBOOK(m_pNotebook->m_Widget), TRUE);
@@ -197,6 +201,7 @@
 
 	gtk_box_pack_start (GTK_BOX (vbox), m_Menubar, FALSE, FALSE, 0);
 	gtk_box_pack_start (GTK_BOX (vbox), m_Toolbar, FALSE, FALSE, 0);
+//LANGBAR	gtk_box_pack_start (GTK_BOX (vbox), m_LangToolbar, FALSE, FALSE, 0);
 	gtk_box_pack_start (GTK_BOX (vbox), m_pNotebook->m_Widget, TRUE, TRUE, 0);
 	gtk_widget_set_size_request(m_pNotebook->m_Widget, 300, 200);
 	gtk_box_pack_start (GTK_BOX (vbox), m_Statusbar, FALSE, FALSE, 0);
@@ -227,6 +232,8 @@
 	if (AppConfig.ShowStatusBar) {
 		gtk_widget_show_all(m_Statusbar);
 	}
+
+//LANGBAR	gtk_widget_show_all((GtkWidget *)m_LangToolbar);
 	
 	m_BlinkTimer = g_timeout_add(600, (GSourceFunc)CMainFrame::OnBlinkTimer, this );
 	m_EverySecondTimer = g_timeout_add(1000, (GSourceFunc)CMainFrame::OnEverySecondTimer, this );
@@ -234,6 +241,10 @@
 	CTelnetView::SetParentFrame(this);
 	CTelnetView::SetWebBrowser(AppConfig.WebBrowser);
 	CTelnetView::SetMailClient(AppConfig.MailClient);
+
+	m_UcsConv = new CUcs2Conv();
+	// CTermView::SetUcs2Conv(conv);
+
 #ifdef USE_WGET
 	CTelnetView::setWgetFiles(AppConfig.UseWgetFiles);
 #endif
@@ -252,6 +263,7 @@
 		site = &AppConfig.m_DefaultSite;
 
 	m_pView = new CTelnetView;
+	m_pView->SetUcs2Conv(m_UcsConv);
 	m_Views.push_back(m_pView);
 
 	CTelnetCon* pCon;
@@ -501,6 +513,8 @@
   m_Menubar = gtk_ui_manager_get_widget (m_UIManager, "/ui/menubar");
   m_Toolbar = gtk_ui_manager_get_widget (m_UIManager, "/ui/toolbar");
   gtk_toolbar_set_style( (GtkToolbar*)m_Toolbar, GTK_TOOLBAR_ICONS );
+//LANGBAR  m_LangToolbar = gtk_toolbar_new();
+//LANGBAR  gtk_toolbar_set_style( (GtkToolbar*)m_LangToolbar, GTK_TOOLBAR_TEXT );
 
   m_EditMenu = gtk_ui_manager_get_widget (m_UIManager, "/ui/edit_popup");
     
@@ -536,6 +550,64 @@
       g_signal_connect( G_OBJECT(action), "activate",
                         G_CALLBACK (CMainFrame::OnJumpToPage),
                         this);
+
+//LANGBAR  -----------START
+/*
+  GtkWidget* sep2 = (GtkWidget*)gtk_separator_tool_item_new();
+  gtk_widget_show(sep2);
+  gtk_container_add (GTK_CONTAINER (m_Toolbar), sep2);
+
+  GtkWidget* lang_label = (GtkWidget*) gtk_label_new(_("Encoding:"));
+
+  GtkWidget* multilang_bar = gtk_hbox_new(FALSE, 0);
+
+  m_LangCodeCombo = (GtkWidget*) gtk_combo_box_new_text();
+
+
+  for (int i = 0; i < EncodingData::GetEntrySize(); i++)
+  {
+      gtk_combo_box_append_text(GTK_COMBO_BOX(m_LangCodeCombo),
+              gettext(EncodingData::GetEncodingDescription(i)));
+  }
+
+  gtk_combo_box_set_active(GTK_COMBO_BOX(m_LangCodeCombo), 0);
+
+  m_SendStartCodeButton = gtk_button_new_with_label(_("Switch"));
+  g_signal_connect( (gpointer)m_SendStartCodeButton, "clicked",
+                    G_CALLBACK (CMainFrame::OnSendStartCode),
+                    this);
+  m_SendEndCodeButton = gtk_button_new_with_label(_("End"));
+  g_signal_connect( (gpointer)m_SendEndCodeButton, "clicked",
+                    G_CALLBACK (CMainFrame::OnSendEndCode),
+                    this);
+  m_HideCheckButton = gtk_check_button_new_with_label(_("Hide"));
+  g_signal_connect( (gpointer)m_HideCheckButton, "toggled",
+                    G_CALLBACK (CMainFrame::OnHideCheck),
+                    this);
+
+  //gtk_widget_set_size_request(m_LangCodeCombo, 0, -1);
+  //gtk_widget_set_size_request(m_SendStartCodeButton, 0, -1);
+  //gtk_widget_set_size_request(m_SendEndCodeButton, 0, -1);
+  gtk_box_pack_start( GTK_BOX(multilang_bar), lang_label, FALSE, FALSE, 4);
+  gtk_box_pack_start( GTK_BOX(multilang_bar), m_LangCodeCombo, TRUE, TRUE, 4);
+  gtk_box_pack_start( GTK_BOX(multilang_bar), m_SendStartCodeButton, TRUE, TRUE, 4);
+  gtk_box_pack_start( GTK_BOX(multilang_bar), m_SendEndCodeButton, TRUE, TRUE, 4);
+  gtk_box_pack_start( GTK_BOX(multilang_bar), m_HideCheckButton, TRUE, TRUE, 4);
+
+
+  g_signal_connect( (gpointer)m_LangCodeCombo, "changed",
+                    G_CALLBACK (CMainFrame::OnLangComboChange),
+                    this);
+
+
+  GtkToolItem* multilang_bar_item = gtk_tool_item_new();
+  gtk_tool_item_set_expand(multilang_bar_item, true);
+  gtk_container_add (GTK_CONTAINER (multilang_bar_item), multilang_bar);
+  gtk_widget_show_all ( (GtkWidget*)multilang_bar_item);
+  gtk_toolbar_insert(GTK_TOOLBAR(m_LangToolbar), multilang_bar_item, -1);
+*/
+//LANGBAR  -----------END
+
       sprintf(name, "<Alt>%d", i % 10);
       gtk_action_group_add_action_with_accel(m_ActionGroup, action, name);
       gtk_container_add (GTK_CONTAINER (jump_menu),
@@ -576,7 +648,7 @@
 #if GTK_CHECK_VERSION(2,10,0)
 	m_TrayIcon = gtk_status_icon_new();
 	gtk_status_icon_set_from_pixbuf(m_TrayIcon, m_MainIcon);
-	gtk_status_icon_set_tooltip(m_TrayIcon, "PCMan X");
+	gtk_status_icon_set_tooltip(m_TrayIcon, "PCMan X (MLS)");
 
 	// Setup popup menu
 	m_TrayPopup = gtk_ui_manager_get_widget(m_UIManager, "/ui/tray_popup");
@@ -754,6 +826,7 @@
 		gtk_window_fullscreen((GtkWindow *)_this->m_Widget);
 		gtk_widget_hide_all((GtkWidget *)_this->m_Menubar);
 		gtk_widget_hide_all((GtkWidget *)_this->m_Toolbar);
+//LANGBAR		gtk_widget_hide_all((GtkWidget *)_this->m_LangToolbar);
 		gtk_widget_hide_all((GtkWidget *)_this->m_Statusbar);
 		_this->m_pNotebook->HideTabs();
 	} else {
@@ -761,12 +834,94 @@
 		gtk_window_unfullscreen((GtkWindow *)_this->m_Widget);
 		gtk_widget_show_all((GtkWidget *)_this->m_Menubar);
 		gtk_widget_show_all((GtkWidget *)_this->m_Toolbar);
+//LANGBAR		gtk_widget_show_all((GtkWidget *)_this->m_LangToolbar);
 		if (AppConfig.ShowStatusBar)
 			gtk_widget_show_all((GtkWidget *)_this->m_Statusbar);
 		_this->m_pNotebook->ShowTabs();
 	}
 }
 
+//LANGBAR  -----------START
+/*
+void CMainFrame::OnLangComboChange(GtkComboBox* widget, CMainFrame* _this)
+{
+	if (_this->m_pView != NULL)
+		_this->m_pView->SetFocus();
+}
+
+void CMainFrame::OnHideCheck(GtkCheckButton *widget, CMainFrame* _this)
+{
+	if (_this->m_pView != NULL)
+		_this->m_pView->SetFocus();
+}
+
+void CMainFrame::OnSendStartCode(GtkButton* widget, CMainFrame* _this)
+{
+	if (_this->m_pView == NULL)
+		return;
+
+	gint select = gtk_combo_box_get_active(GTK_COMBO_BOX(_this->m_LangCodeCombo));
+	gboolean isHide = gtk_toggle_button_get_active(
+			GTK_TOGGLE_BUTTON(_this->m_HideCheckButton) );
+	gchar* langcode;
+
+	if (select > 0)
+	{
+		string result;
+		string esc = _this->GetCurCon()->m_Site.GetEscapeChar();
+
+		if (isHide)
+		{
+			result.append(esc);
+			result.append("[30m");
+		}
+
+		result.append(1, EncodingData::EncodingCodeStartChar);
+		langcode = EncodingData::GetEncodingLang(select);
+		result.append(langcode);
+		result.append(1, EncodingData::EncodingCodeEndChar);
+
+		if (isHide)
+		{
+			result.append(esc);
+			result.append("[m");
+		}
+
+		_this->GetCurCon()->SendString(result);
+	}
+
+	_this->m_pView->SetFocus();
+}
+
+void CMainFrame::OnSendEndCode(GtkButton* widget, CMainFrame* _this)
+{
+	if (_this->m_pView == NULL)
+		return;
+
+	gboolean isHide = gtk_toggle_button_get_active(
+			GTK_TOGGLE_BUTTON(_this->m_HideCheckButton) );
+	string result;
+	string esc = _this->GetCurCon()->m_Site.GetEscapeChar();
+
+	if (isHide)
+	{
+		result.append(esc);
+		result.append("[30m");
+	}
+	result.append(1, EncodingData::EncodingCodeStartChar);
+	result.append(1, EncodingData::EncodingCodeEndChar);
+	if (isHide)
+	{
+		result.append(esc);
+		result.append("[m");
+	}
+
+	_this->GetCurCon()->SendString(result);
+	_this->m_pView->SetFocus();
+}
+*/
+//LANGBAR  -----------END
+
 void CMainFrame::OnSimpleMode(GtkMenuItem* mitem UNUSED, CMainFrame* _this)
 {
 	if (_this->m_Mode != SIMPLE_MODE) {
@@ -804,7 +959,7 @@
 	GtkWidget* dlg = gtk_message_dialog_new_with_markup( (GtkWindow*)_this->m_Widget,
 						GTK_DIALOG_DESTROY_WITH_PARENT,
 						GTK_MESSAGE_INFO, GTK_BUTTONS_OK,
-						_("<b>PCMan X %s</b>\nA free BBS client developed with GTK+ 2.x\n\n"
+						_("<b>PCMan X %s</b>\nA free BBS client developed with GTK+ 2.x.\n(modified for multi-language support.)\n\n"
 						"Copyright (c) 2005-2008\n"
 						"License: GNU Genral Public License\n"
 						"Project Homepage: http://pcmanx.csie.net\n"
@@ -1210,6 +1365,8 @@
 
 void CMainFrame::OnDestroy()
 {
+	delete m_UcsConv;
+	
 	g_source_remove( m_BlinkTimer );
 	g_source_remove( m_EverySecondTimer );
 
@@ -1250,7 +1407,7 @@
 	GtkWidget* dlg = gtk_message_dialog_new( (GtkWindow*)m_Widget,
 						GTK_DIALOG_DESTROY_WITH_PARENT,
 						GTK_MESSAGE_QUESTION, GTK_BUTTONS_OK_CANCEL,
-						_("Quit PCMan X ?"));
+						_("Quit PCMan X (MLS) ?"));
 	bool close = gtk_dialog_run((GtkDialog*)dlg) == GTK_RESPONSE_OK;
 	gtk_widget_destroy(dlg);
 	return close;
@@ -1402,7 +1559,7 @@
 	m_pView = view;
 	if( !m_pView || !m_pView->GetCon() )
 	{
-		gtk_window_set_title (GTK_WINDOW (m_Widget), "PCMan X "VERSION );
+		gtk_window_set_title (GTK_WINDOW (m_Widget), "PCMan X (MLS) "VERSION );
 		gtk_entry_set_text( GTK_ENTRY(m_URLEntry), "");
 		return;
 	}
@@ -1415,7 +1572,7 @@
 	if( ! con->IsClosed() )
 		m_pNotebook->SetPageTitle( m_pView, title );
 
-	title += " - PCMan X "VERSION;
+	title += " - PCMan X (MLS) "VERSION;
 	gtk_window_set_title (GTK_WINDOW (m_Widget), title.c_str() );
 
 	char time_str[100];
diff -ruN pcmanx-gtk2-0.3.9/src/mainframe.h pcmanx-mls-gtk2-0.3.9/src/mainframe.h
--- pcmanx-gtk2-0.3.9/src/mainframe.h	2009-08-03 10:20:01.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/mainframe.h	2009-09-26 17:20:09.000000000 +0800
@@ -36,6 +36,7 @@
 
 using namespace std;
 
+#include "Ucs2Conv.h"
 #include "telnetview.h"
 #include <signal.h>
 
@@ -103,6 +104,15 @@
 	int GetViewIndex(CTermView* view);
 	void SwitchToCon(CTelnetCon* con);
 
+//LANGBAR
+/*
+	static void OnLangComboChange(GtkComboBox* widget, CMainFrame* _this);
+	static void OnSendStartCode(GtkButton *widget, CMainFrame* _this);
+	static void OnSendEndCode(GtkButton *widget, CMainFrame* _this);
+	static void OnHideCheck(GtkCheckButton *widget, CMainFrame* _this);
+*/
+//LANGBAR
+
 	vector<CTelnetView*> m_Views;
 #ifdef USE_DOCKLET
 #if GTK_CHECK_VERSION(2,10,0)
@@ -131,6 +141,8 @@
 	  return gtk_statusbar_pop(GTK_STATUSBAR(m_Statusbar), context_id);
 	}
 
+//LANGBAR	GtkWidget* GetLangCodeCombo() { return m_LangCodeCombo; }
+
 protected:
 	void MakeUI();
 	static void OnNewCon(GtkMenuItem* mitem, CMainFrame* _this);
@@ -178,6 +190,7 @@
 protected:
 	CTelnetView* m_pView;
 	CNotebook* m_pNotebook;
+	CUcs2Conv* m_UcsConv;
 	GtkUIManager* m_UIManager;
 	GtkActionGroup* m_ActionGroup;
 	GtkWidget* m_Toolbar;
@@ -196,6 +209,16 @@
 	GtkTooltips* m_Tooltips;
 	GtkLabel* m_StatusBarTime;
 
+//LANGBAR
+/*
+	GtkWidget* m_LangToolbar;
+	GtkWidget* m_LangCodeCombo;
+	GtkWidget* m_SendStartCodeButton;
+	GtkWidget* m_SendEndCodeButton;
+	GtkWidget* m_HideCheckButton;
+*/
+//LANGBAR
+
 #ifdef USE_NANCY
 	GtkLabel* m_StatusBarBotState;
 	GtkRadioMenuItem* m_DisableCurBotRadio;
diff -ruN pcmanx-gtk2-0.3.9/src/Makefile.am pcmanx-mls-gtk2-0.3.9/src/Makefile.am
--- pcmanx-gtk2-0.3.9/src/Makefile.am	2009-04-30 23:46:47.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/Makefile.am	2009-09-26 17:21:03.000000000 +0800
@@ -76,6 +76,10 @@
 	qqwryseeker/qqwryseeker.c qqwryseeker/qqwryseeker.h
 endif
 
+MLS_SOURCES = \
+	Ucs2Conv.cpp Ucs2Conv.h \
+	encodingdata.cpp encodingdata.h
+
 pcmanx_SOURCES = \
 	$(DOCKLET_SOURCES) \
 	$(NOTIFIER_SOURCES) \
@@ -83,6 +87,7 @@
 	$(NANCY_SOURCES) \
 	$(VIEW_IMPLEMENTATION_SOURCES) \
 	$(QQWRYSEEKER_SOURCES) \
+	$(MLS_SOURCES) \
 	appconfig.cpp appconfig.h \
 	notebook.cpp notebook.h \
 	sitelistdlg.cpp sitelistdlg.h \
diff -ruN pcmanx-gtk2-0.3.9/src/Makefile.in pcmanx-mls-gtk2-0.3.9/src/Makefile.in
--- pcmanx-gtk2-0.3.9/src/Makefile.in	2009-08-03 16:38:22.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/Makefile.in	2009-09-26 17:25:32.000000000 +0800
@@ -62,7 +62,9 @@
 	listbox.h editfavdlg.cpp editfavdlg.h mainframe.cpp \
 	mainframe.h sitedlg.cpp sitedlg.h emoticondlg.cpp \
 	emoticondlg.h autologinpage.cpp autologinpage.h \
-	downarticledlg.cpp downarticledlg.h
+	downarticledlg.cpp downarticledlg.h \
+	Ucs2Conv.cpp Ucs2Conv.h \
+	encodingdata.cpp encodingdata.h
 am__objects_1 = clipboard.$(OBJEXT) eggtrayicon.$(OBJEXT)
 @USE_DOCKLET_TRUE@am__objects_2 = $(am__objects_1)
 am__objects_3 = notifier-impl.$(OBJEXT) working_area.$(OBJEXT)
@@ -81,7 +83,9 @@
 	prefdlg.$(OBJEXT) dialog.$(OBJEXT) listbox.$(OBJEXT) \
 	editfavdlg.$(OBJEXT) mainframe.$(OBJEXT) sitedlg.$(OBJEXT) \
 	emoticondlg.$(OBJEXT) autologinpage.$(OBJEXT) \
-	downarticledlg.$(OBJEXT)
+	downarticledlg.$(OBJEXT) \
+	encodingdata.$(OBJEXT) \
+	Ucs2Conv.$(OBJEXT)
 pcmanx_OBJECTS = $(am_pcmanx_OBJECTS)
 am__DEPENDENCIES_1 =
 pcmanx_DEPENDENCIES = $(am__DEPENDENCIES_1) $(LIBPCMANX_CORE) \
@@ -355,6 +359,10 @@
 @USE_IPLOOKUP_TRUE@QQWRYSEEKER_SOURCES = \
 @USE_IPLOOKUP_TRUE@	qqwryseeker/qqwryseeker.c qqwryseeker/qqwryseeker.h
 
+MLS_SOURCES = \
+	Ucs2Conv.cpp Ucs2Conv.h \
+	encodingdata.cpp encodingdata.h
+
 pcmanx_SOURCES = \
 	$(DOCKLET_SOURCES) \
 	$(NOTIFIER_SOURCES) \
@@ -362,6 +370,7 @@
 	$(NANCY_SOURCES) \
 	$(VIEW_IMPLEMENTATION_SOURCES) \
 	$(QQWRYSEEKER_SOURCES) \
+	$(MLS_SOURCES) \
 	appconfig.cpp appconfig.h \
 	notebook.cpp notebook.h \
 	sitelistdlg.cpp sitelistdlg.h \
@@ -451,6 +460,7 @@
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Ucs2Conv.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/appconfig.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/autologinpage.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/clipboard.Po@am__quote@
@@ -460,6 +470,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/editfavdlg.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eggtrayicon.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emoticondlg.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/encodingdata.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/generalprefpage.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/inputdialog.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/listbox.Po@am__quote@
diff -ruN pcmanx-gtk2-0.3.9/src/Ucs2Conv.cpp pcmanx-mls-gtk2-0.3.9/src/Ucs2Conv.cpp
--- pcmanx-gtk2-0.3.9/src/Ucs2Conv.cpp	1970-01-01 08:00:00.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/Ucs2Conv.cpp	2009-09-26 17:27:36.000000000 +0800
@@ -0,0 +1,206 @@
+//////////////////////////////////////////////////////////////////////
+//
+// CUcs2Conv.cpp: implementation of the CUcs2Conv class.
+//
+//////////////////////////////////////////////////////////////////////
+#ifdef __GNUG__
+    #pragma interface "Ucs2Conv.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+//#include <io.h>	// For _filelength, which is Microsoft specific
+#include "Ucs2Conv.h"
+
+#ifdef _DEBUG
+    #undef THIS_FILE
+    static char THIS_FILE[] = __FILE__;
+    #define new DEBUG_NEW
+#endif
+
+#define BIG5_TO_UCS2_TABLE (DATADIR "/pcmanx/_B2U")
+#define UCS2_TO_BIG5_TABLE (DATADIR "/pcmanx/_U2B")
+
+using namespace std;
+
+//////////////////////////////////////////////////////////////////////
+// Construction/Destruction
+//////////////////////////////////////////////////////////////////////
+
+CUcs2Conv::CUcs2Conv()
+{
+	InitBig52Ucs2Tab();
+	InitUcs22Big5Tab();
+}
+
+CUcs2Conv::~CUcs2Conv()
+{
+
+}
+
+void CUcs2Conv::Big52Ucs2(const char* text_in, wchar_t* text_out)
+{
+	const int SEG_LEN = (0x7E - 0x40) + (0xFE - 0xA1) + 2;//
+	const int _XX = 0xA1 - 0x7E - 1;//
+
+	for (; *text_in; text_in++, text_out++)
+	{
+		unsigned char ch1, ch2;
+		if ((ch1 = *text_in) >= 0x81 && ch1 <= 0xFE && (ch2 = *(text_in + 1)) >= 0x40)
+		{
+
+			int segment = (ch1 - 0x81) * SEG_LEN + 1;
+			int offset = (ch2 < 0xa1 ? ch2 - 0x40 : ch2 - 0x40 - _XX);
+			int index = 2 * (segment + offset) - 2 ;
+
+			*text_out = m_Big52Ucs2_Tab[index] << 8 | m_Big52Ucs2_Tab[index+1];
+			text_in++;
+		}
+
+		// FIXME: It might cause logical problems due to regarding the characters
+		// out of Big5 encoding as ASCII.
+		else
+		{
+			*text_out = *text_in;
+		}
+	}
+}
+
+void CUcs2Conv::Ucs22Big5(const wchar_t* text_in, char* text_out)
+{
+
+	for (; *text_in; text_in++, text_out++)
+	{
+		if (*text_in >= 0x81)
+		{
+			int index = 2 * (*text_in - 0x81);
+
+			*text_out = m_Ucs22Big5_Tab[index];
+			text_out++;
+			*text_out = m_Ucs22Big5_Tab[index+1];
+		}
+
+		else
+		{
+			*text_out = (char) * text_in;
+		}
+	}
+}
+
+gchar* CUcs2Conv::Big52Utf8(const char* text_in, int len, gsize* written_length)
+{
+	wchar_t *outbuf = new wchar_t[len * 2 + 1];
+	int buf_size = 0, i;
+	gchar* result = NULL;
+	buf_size = Big52Ucs2(text_in, outbuf, len);
+	outbuf[buf_size] = 0;
+
+	gunichar2* wbuf = new gunichar2[buf_size + 1];
+	for (i = 0; i < buf_size; i++)
+		wbuf[i] = outbuf[i];
+	wbuf[i] = 0;
+
+	result = g_utf16_to_utf8((gunichar2*)wbuf, -1, NULL, (glong*)written_length, NULL);
+	delete[] outbuf;
+	delete[] wbuf;
+
+	return result;
+}
+
+gchar* CUcs2Conv::Utf82Big5(const char* text_in, gsize* written_length)
+{
+	glong convl;
+	int size = 0, i;
+	gunichar2* tmpbuf = g_utf8_to_utf16(text_in, -1, NULL, &convl, NULL);
+	size = convl * 4 + 1;
+	wchar_t* wbuf = new wchar_t[convl + 1];
+	for ( i = 0; i < convl; i++)
+		wbuf[i] = tmpbuf[i];
+	wbuf[i] = 0;
+
+	gchar* outbuf = (gchar*)g_malloc(sizeof(gchar) * size);
+	memset(outbuf, 0, size);
+	Ucs22Big5((wchar_t*)wbuf, outbuf);
+	*written_length = strlen(outbuf);
+
+	delete[] wbuf;
+
+	return outbuf;
+}
+
+size_t CUcs2Conv::Big52Ucs2(const char* text_in, wchar_t* text_out, int len)
+{
+	const int SEG_LEN = (0x7E - 0x40) + (0xFE - 0xA1) + 2;//
+	const int _XX = 0xA1 - 0x7E - 1;
+	wchar_t* pstart = text_out;
+
+	for (int i = 0; i < len; ++text_in, ++text_out, ++i)
+	{
+		unsigned char ch1, ch2;
+		if ((ch1 = *text_in) >= 0x81 && (ch2 = *(text_in + 1)) >= 0x40)
+		{
+			int index = 2 * (
+					((ch1 - 0x81) * SEG_LEN + 1) +
+					(ch2 < 0xa1 ? ch2 - 0x40 : ch2 - 0x40 - _XX)
+					) - 2 ;
+
+			*text_out = (m_Big52Ucs2_Tab[index] << 8) | m_Big52Ucs2_Tab[index+1];
+			++text_in;
+			++i;
+		}
+
+		else
+		{
+			// Under most conditions, there are DBCS Big5 Chinese characters
+			// in low byte.
+			if (ch1 >= 0x81)
+			{
+				*text_out = 0x3f;
+			}
+			// Normal ASCII characters.
+			else
+			{
+				*text_out = *text_in;
+			}
+		}
+	}
+	return (text_out - pstart);
+}
+
+bool CUcs2Conv::InitBig52Ucs2Tab()
+{
+	FILE* file = fopen(BIG5_TO_UCS2_TABLE, "rb");
+	long f_size = 0L;
+
+	if (file)
+	{
+		// obtains file size
+		fseek(file, 0, SEEK_END);
+		f_size = ftell(file);
+		rewind(file);
+
+		fread(m_Big52Ucs2_Tab, 1, f_size, file);
+		fclose(file);
+		return true;
+	}
+	return false;
+}
+
+bool CUcs2Conv::InitUcs22Big5Tab()
+{
+	FILE* file = fopen(UCS2_TO_BIG5_TABLE, "rb");
+	long f_size = 0L;
+
+	if (file)
+	{
+		// obtains file size
+		fseek(file, 0, SEEK_END);
+		f_size = ftell(file);
+		rewind(file);
+
+		fread(m_Ucs22Big5_Tab, 1, f_size, file);
+		fclose(file);
+		return true;
+	}
+	return false;
+}
\ 檔案末沒有 newline 字元
diff -ruN pcmanx-gtk2-0.3.9/src/Ucs2Conv.h pcmanx-mls-gtk2-0.3.9/src/Ucs2Conv.h
--- pcmanx-gtk2-0.3.9/src/Ucs2Conv.h	1970-01-01 08:00:00.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/Ucs2Conv.h	2009-09-26 17:28:36.000000000 +0800
@@ -0,0 +1,40 @@
+//////////////////////////////////////////////////////////////////////
+//
+// Ucs2Conv.h: interface for the CUcs2Conv class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#ifndef _UCS2CONV_H_
+#define _UCS2CONV_H_
+
+/*#ifdef __GNUG__
+    #pragma interface "Ucs2Conv.h"
+#endif */
+
+#include <glib.h>
+#include "pcmanx_utils.h"
+
+#define B2U_TAB_SIZE 39564 +2
+#define U2B_TAB_SIZE 130814+2
+
+class CUcs2Conv
+{
+public:
+	X_EXPORT gchar* Big52Utf8(const char* text_in, int len, gsize* written_length);
+	gchar* Utf82Big5(const char* text_in, gsize* written_length);
+	void Big52Ucs2(const char* text_in, wchar_t* text_out);
+	size_t Big52Ucs2(const char* text_in, wchar_t* text_out, int len);
+	void Ucs22Big5(const wchar_t* text_in, char* text_out);
+	CUcs2Conv();
+	virtual ~CUcs2Conv();
+
+protected:
+	unsigned char m_Big52Ucs2_Tab[B2U_TAB_SIZE];
+	unsigned char m_Ucs22Big5_Tab[U2B_TAB_SIZE];
+
+public:   /* FIXME */
+	bool InitBig52Ucs2Tab();
+	bool InitUcs22Big5Tab();
+};
+
+#endif // _UCS2CONV_H_
\ 檔案末沒有 newline 字元
diff -ruN pcmanx-gtk2-0.3.9/src/view/telnetview.cpp pcmanx-mls-gtk2-0.3.9/src/view/telnetview.cpp
--- pcmanx-gtk2-0.3.9/src/view/telnetview.cpp	2009-05-29 13:29:38.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/view/telnetview.cpp	2009-09-26 17:56:21.000000000 +0800
@@ -22,17 +22,20 @@
 
 #include <glib/gi18n.h>
 
-#include <string.h>
-
 #include <gdk/gdkkeysyms.h>
 #include <ctype.h>
 #include <string.h>
 #include <stdlib.h>
 #include <algorithm>
+#include <pango/pangoxft.h>
 
+#include "font.h"
 #include "telnetview.h"
 #include "telnetcon.h"
 
+#include "encodingdata.h"
+#include "Ucs2Conv.h"
+
 #if !defined(MOZ_PLUGIN)
 #include "mainframe.h"
 #include "stringutil.h"
@@ -67,7 +70,25 @@
 void CTelnetView::OnTextInput(const gchar* text)
 {
 	gsize l;
-	gchar* _text = g_convert(text, strlen(text), GetCon()->m_Site.m_Encoding.c_str(), "UTF-8", NULL, &l, NULL);
+	gchar* _text = NULL;
+
+	// get the encoding the user want to convert
+//LANGBAR	gint select_lang = gtk_combo_box_get_active(GTK_COMBO_BOX(m_pParentFrame->GetLangCodeCombo()));
+/* LANGBAR */	gint select_lang = 0;
+
+	if (select_lang == 0) // Default
+	{
+		if (GetCon()->m_Site.m_Encoding.compare("Big5") == 0)
+			_text = m_UcsConv->Utf82Big5(text, &l);
+		else
+			_text = g_convert(text, strlen(text), GetCon()->m_Site.m_Encoding.c_str(), "UTF-8", NULL, &l, NULL);
+	}
+	else
+	{
+		gchar* select_encoding = EncodingData::GetEncodingName(select_lang);
+		_text = g_convert(text, strlen(text), select_encoding, "UTF-8", NULL, &l, NULL);
+	}
+
 	if( _text )
 	{
 		((CTelnetCon*)m_pTermData)->Send(_text, l);
@@ -579,6 +600,51 @@
 */	return false;
 }
 
+void CTelnetView::CopyToClipboard(bool primary, bool with_color, bool trim)
+{
+	string text;
+	if(!m_pTermData)
+		return;
+	m_s_ANSIColorStr = "";
+	if( with_color )
+		text = m_pTermData->GetSelectedTextWithColor(trim);
+	else
+		text = m_pTermData->GetSelectedText(trim);
+
+	gsize wl = 0;
+
+//LANGBAR	gint select_lang = gtk_combo_box_get_active(GTK_COMBO_BOX(m_pParentFrame->GetLangCodeCombo()));
+/* LANGBAR */	gint select_lang = 0;
+
+	const gchar* utext = NULL;
+
+	if (select_lang == 0)
+	{
+		if (m_pTermData->m_Encoding.compare("Big5") == 0)
+			utext = m_UcsConv->Big52Utf8(text.c_str(), text.length(), &wl);
+		else
+			utext = g_convert_with_fallback( text.c_str(), text.length(),
+					"utf-8", m_pTermData->m_Encoding.c_str(), "?", NULL, &wl, NULL);
+	}
+	else if (select_lang > 0 && select_lang < EncodingData::GetEntrySize())
+	{
+		utext = g_convert_with_fallback( text.c_str(), text.length(),
+				"utf-8", EncodingData::GetEncodingName(select_lang), "?", NULL, &wl, NULL);
+	}
+	if(!utext)
+		return;
+
+	if( with_color )
+		m_s_ANSIColorStr = string(utext);
+	else
+	{
+		GtkClipboard* clipboard = gtk_clipboard_get(  primary ? GDK_SELECTION_PRIMARY : GDK_NONE );
+		gtk_clipboard_set_text(clipboard, utext, wl );
+	}
+	INFO("select: %s", utext);
+	g_free((void*)utext);
+}
+
 void CTelnetView::DoPasteFromClipboard(string text, bool contain_ansi_color)
 {
 	if( GetCon() )
@@ -628,7 +694,26 @@
 			// autowrap be enabled
 			unsigned int len = 0, max_len = GetCon()->m_Site.m_AutoWrapOnPaste;
 			gsize convl;
-			gchar* locale_text = g_convert(text.c_str(), text.length(), GetCon()->m_Site.m_Encoding.c_str(), "UTF-8", NULL, &convl, NULL);
+
+			// get the encoding the user want to convert
+//LANGBAR		gint select_lang = gtk_combo_box_get_active(GTK_COMBO_BOX(m_pParentFrame->GetLangCodeCombo()));
+/* LANGBAR */		gint select_lang = 0;
+
+			gchar* locale_text = NULL;
+
+			if (select_lang == 0) // Default
+			{
+				if (GetCon()->m_Site.m_Encoding.compare("Big5") == 0)
+					locale_text = m_UcsConv->Utf82Big5(text.c_str(), &convl);
+				else
+					locale_text = g_convert(text.c_str(), text.length(), GetCon()->m_Site.m_Encoding.c_str(), "UTF-8", NULL, &convl, NULL);
+			}
+			else
+			{
+				gchar* select_encoding = EncodingData::GetEncodingName(select_lang);
+				locale_text = g_convert(text.c_str(), text.length(), select_encoding, "UTF-8", NULL, &convl, NULL);
+			}
+
 			if( !locale_text )
 				return;
 			// FIXME: Convert UTF-8 string to locale string.to prevent invalid UTF-8 string
diff -ruN pcmanx-gtk2-0.3.9/src/view/telnetview.h pcmanx-mls-gtk2-0.3.9/src/view/telnetview.h
--- pcmanx-gtk2-0.3.9/src/view/telnetview.h	2009-04-30 23:46:48.000000000 +0800
+++ pcmanx-mls-gtk2-0.3.9/src/view/telnetview.h	2009-09-26 17:57:18.000000000 +0800
@@ -26,6 +26,7 @@
 #include "pcmanx_utils.h"
 
 #include "termview.h"
+#include "Ucs2Conv.h"
 
 #if defined(USE_IPLOOKUP) && !defined(MOZ_PLUGIN)
 #include "qqwryseeker/qqwryseeker.h"
@@ -36,6 +37,7 @@
 */
 class CTelnetCon;
 class CMainFrame;
+class CUcs2Conv;
 class CTelnetView : public CTermView
 {
 friend class CMainFrame;
@@ -68,6 +70,7 @@
 #endif // defined(USE_MOUSE) && !defined(MOZ_PLUGIN)
     void OnRButtonDown(GdkEventButton* evt);
     bool PreKeyDown(GdkEventKey* evt);
+    virtual void CopyToClipboard(bool primary, bool with_color, bool trim);
     virtual void DoPasteFromClipboard(string text, bool contain_ansi_color);
     void OnDestroy();
 
